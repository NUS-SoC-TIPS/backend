generator client {
  provider = "prisma-client-js"

  // Explanation of each of these:
  // postgresqlExtensions: Allows PG extensions, see https://www.postgresql.org/docs/current/sql-createextension.html.
  // fieldReference: Allows you to compare columns in the same table e.g. `where: { quantity: { lte: prisma.product.fields.warnQuantity } }`
  // filteredRelationCount: Allows you to do e.g. select: { _count: { select: { posts: { where: { title: 'Hello!' } } } } } -> returns count
  // extendedWhereUnique: Allows you to include non-unique fields in `where` in addition to min. one unique field.
  // orderByNulls: Allows you to do e.g. `orderBy: { updatedAt: { sort: 'asc', nulls: 'last' } }`
  // clientExtensions: Allows client extensions, see https://www.prisma.io/docs/concepts/components/prisma-client/client-extensions
  previewFeatures = ["postgresqlExtensions", "fieldReference", "filteredRelationCount", "extendedWhereUnique", "orderByNulls", "clientExtensions"]

  // We need this due to generate issue with Prisma and Yarn v2: https://github.com/prisma/prisma/issues/1439
  output = "../src/prisma/generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String               @id // ID from GitHub
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  githubUsername      String               @map("github_username")
  photoUrl            String               @map("photo_url") // Provided by GitHub
  profileUrl          String               @map("profile_url") // Also provided by GitHub
  name                String
  role                UserRole             @default(NORMAL)
  settings            Settings?
  exclusions          Exclusion[]
  questionSubmissions QuestionSubmission[]
  roomRecordUsers     RoomRecordUser[]
  roomUsers           RoomUser[]

  @@map("users")
}

model Settings {
  id                         Int        @id @default(autoincrement())
  createdAt                  DateTime   @default(now()) @map("created_at")
  updatedAt                  DateTime   @updatedAt @map("updated_at")
  userId                     String     @unique @map("user_id")
  hasUpdatedName             Boolean    @map("has_updated_name")
  hasUpdatedPhoto            Boolean    @map("has_updated_photo")
  preferredInterviewLanguage Language?  @map("preferred_interview_language")
  preferredKeyBinding        KeyBinding @default(STANDARD) @map("preferred_key_binding")
  user                       User       @relation(fields: [userId], references: [id])

  @@map("settings")
}

model Room {
  id          Int          @id @default(autoincrement())
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")
  closedAt    DateTime?    @map("closed_at") // Null if not closed
  slug        String // Random word slug generated at app level
  status      RoomStatus   @default(OPEN)
  roomRecords RoomRecord[]
  roomUsers   RoomUser[] // Max 2 room users

  @@map("rooms")
}

model RoomUser {
  id     Int    @id @default(autoincrement())
  roomId Int
  userId String
  room   Room   @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@map("room_users")
}

model RoomRecord {
  id              Int              @id @default(autoincrement())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  isRoleplay      Boolean          @default(false)
  duration        Float // In milliseconds. Time taken for both users if general, else time taken for specific turn.
  codeWritten     String // Code written by both users if general, else by interviewee
  isSolved        Boolean          @default(false)
  roomId          Int
  questionSlug    String?
  language        Language
  questionSource  QuestionSource?
  question        Question?        @relation(fields: [questionSlug, questionSource], references: [slug, source]) // Null if general
  room            Room             @relation(fields: [roomId], references: [id], onDelete: Cascade)
  roomRecordUsers RoomRecordUser[]

  @@map("room_records")
}

model Question {
  slug                String
  name                String
  isPremium           Boolean
  difficulty          QuestionDifficulty
  source              QuestionSource
  type                QuestionType
  id                  Int
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  questionSubmissions QuestionSubmission[]
  roomRecords         RoomRecord[]

  @@id([slug, source])
  @@unique([id, source])
  @@map("questions")
}

// 1 pair of users per room record
model RoomRecordUser {
  id            Int        @id @default(autoincrement())
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  isInterviewer Boolean // false if record is general, but it's not really used
  notes         String // Notes taken by this user during interview
  userId        String
  roomRecordId  Int
  roomRecord    RoomRecord @relation(fields: [roomRecordId], references: [id])
  user          User       @relation(fields: [userId], references: [id])

  @@unique([roomRecordId, userId])
  @@map("room_record_users")
}

model QuestionSubmission {
  id             Int            @id @default(autoincrement())
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  codeWritten    String
  userId         String
  questionSlug   String
  languageUsed   Language
  questionSource QuestionSource
  question       Question       @relation(fields: [questionSlug, questionSource], references: [slug, source])
  user           User           @relation(fields: [userId], references: [id])

  @@map("question_submissions")
}

model Window {
  id               Int         @id
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  startAt          DateTime
  endAt            DateTime
  iteration        Int
  requireInterview Boolean
  numQuestions     Int         @default(7)
  exclusions       Exclusion[]

  @@map("windows")
}

model Exclusion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  windowId  Int
  reason    String
  user      User     @relation(fields: [userId], references: [id])
  window    Window   @relation(fields: [windowId], references: [id])

  @@unique([userId, windowId])
  @@map("exclusions")
}

enum UserRole {
  NORMAL
  ADMIN

  @@map("user_role")
}

enum RoomStatus {
  OPEN
  CLOSED_MANUALLY
  CLOSED_AUTOMATICALLY

  @@map("room_status")
}

enum Language {
  // For LeetCode Algorithm + JavaScript + Concurrency questions
  C_PLUS_PLUS
  JAVA
  PYTHON
  PYTHON_THREE
  C
  C_SHARP
  JAVASCRIPT
  RUBY
  SWIFT
  GO
  SCALA
  KOTLIN
  RUST
  PHP
  TYPESCRIPT
  RACKET
  ERLANG
  ELIXIR
  DART

  // For LeetCode Database questions
  MY_SQL
  MS_SQL_SERVER
  ORACLE

  // For LeetCode Shell questions
  BASH

  // For Kattis questions
  APL
  COBOL
  LISP
  F_SHARP
  FORTRAN
  GERBIL
  HASKELL
  JULIA
  OBJECTIVE_C
  OCAML
  PASCAL
  PROLOG

  @@map("language")
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD

  @@map("question_difficulty")
}

// Mainly used for LeetCode questions, which are categorised by types
enum QuestionType {
  ALGORITHMS
  DATABASE
  JAVASCRIPT
  SHELL
  CONCURRENCY

  @@map("question_type")
}

enum QuestionSource {
  LEETCODE
  HACKERRANK
  KATTIS
  CUSTOM

  @@map("question_source")
}

enum KeyBinding {
  STANDARD
  VIM
  VS_CODE

  @@map("key_binding")
}
